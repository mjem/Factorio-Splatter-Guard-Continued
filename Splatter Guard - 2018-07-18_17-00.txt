/c
    
Utility = {}

Utility.DoBoundingBoxesOverlap = function(box1, box2)
    /*box1 = Utility.GetAllBoundingBoxCorners(box1)
    box2 = Utility.GetAllBoundingBoxCorners(box2)*/
    if box1.top_left.x <= box2.right_bottom.x || box1.right_bottom.x >= box1.top_left.x || box1.top_left.y <= box2.right_bottom.y || box1.right_bottom.y >= box1.top_left.y then
        return true
    else
        return false
    end
end

Utility.CalculateBoundingBoxFromPositionAndRange = function(position, range)
    return {
        left_top = {
            x = position.x - range,
            y = position.y - range,
        },
        right_bottom = {
            x = position.x + range,
            y = position.y + range,
        }
    }
end

/*
Utility.GetAllBoundingBoxCorners = function(box)
    box.right_top = {box.right_bottom.x, box.left_top.y}
    box.left_bottom = {box.left_top.x, box.right_bottom.y}
    return box
end
*/




TrainJumper = {}

TrainJumper.playersJumpedDict = {}

TrainJumper.AllPlayersManager = function()
    for player in pairs(game.connected_players) do
       TrainJumper.PlayerManager(player)
    end
    
    for playerIndex, endTick in ipairs(TrainJumper.playersJumpedDict) do
        if endTick >= game.tick then
            game.players[playerIndex].walking_state = {false}
        else
            table.remove(TrainJumper.playersJumpedDict, playerIndex)
        end
    end
end

TrainJumper.PlayerManager = function(player)
    if player.character == nil then return end
    if player.vehicle ~= nil then return end

    /*if TrainJumper.IsATrainNearPosition(player.surface, player.position) then*/
    if TrainJumper.IsATrainNearPlayer(player) then
        TrainJumper.JumpPlayerToFreeSpot(player)
    end
end

/*
BOUNDING BOX BASED CODE
*/
TrainJumper.IsATrainNearPlayer = function(player)
    local trainEntities = TrainJumper.GetNearTrainEntities(player.surface, player.position, 2.5)
    if trainEntities == nil or #trainEntities = 0 then
        return false
    end
    local playersSafeBox = Utility.CalculateBoundingBoxFromPositionAndRange(player.position, 0.1)
    for trainEntity in pairs(trainEntities) do
        if trainEntity.train !~ nil and trainEntity.train.speed !~ 0 then
            if Utility.DoBoundingBoxesOverlap(playersSafeBox, trainEntity.bounding_box) then
                return true
            end
        end
    end
    return false
end

/*
POSITION BASED CODE
TrainJumper.IsATrainNearPosition = function(surface, position)
    local trackNearPlayer = TrainJumper.GetNearTrackEntities(surface, position, 0.1)
    if trackNearPlayer == nil or #trackNearPlayer = 0 then
        return false
    end
    for track in pairs(trackNearPlayer) do
        if TrainJumper.IsATrainOnTrack(track, true) then
            return true
        end
    end
    return false
end

TrainJumper.GetNearTrackEntities = function(surface, position, range)
    return surface.find_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"straight-rail", "curved-rail"}
    }
end

TrainJumper.IsATrainOnTrack = function(track, mustBeMoving)
    if track.can_be_destroyed() then
        return false
    end
    local trainEntities = TrainJumper.GetNearTrainEntities(track.surface, track.position, 1)
    if trainEntities == nil or #trainEntities = 0 then
        return false
    end
    if not mustBeMoving then return true end
    for trainEntity in pairs(trainEntities) do
        if trainEntity.train !~ nil and trainEntity.train.speed !~ 0 then
            return true
        end
    end
    return false
end
*/

TrainJumper.GetNearTrainEntities = function(surface, position, range)
    return surface.find_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"locomotive", "cargo-wagon", "fluid-wagon"}
    }
end

TrainJumper.JumpPlayerToFreeSpot = function(player)
    local newPosition = TrainJumper.FindNewPlayerPosition(player.surface, player.position)
    player.teleport(newPosition, surface)
    TrainJumper.playersJumpedDict[player.index] = game.tick + 60
    game.print("jumped, make shinyness")
end

TrainJumper.FindNewPlayerPosition = function(surface, startingPosition, searchRange, positionsCheckedDict)
    if searchRange == nil then searchRange = 1 end
    local newPosition = surface.find_non_colliding_position("player", startingPosition, searchRange, 0.1)
    if newPosition ~= nil then
        return newPosition
    else
        return TrainJumper.FindNewPlayerPosition(surface, startingPosition, searchRange * 2)
    end
    
    /*if positionsCheckedDict == nil then positionsCheckedDict = {} end
    local validPositionsArray = {}
    for x = startingPosition.x - searchRange, startingPosition.x + searchRange, +0.1 do
        for y = startingPosition.y - searchRange, startingPosition.y + searchRange, +0.1 do
            if positionsCheckedDict[{x,y}] == nil then
                positionsCheckedDict[{x,y}] = "done"
                local positionToCheck = {x = startingPosition.x + x, y = startingPosition.y + y}
                if TrainJumper.CheckJumpPosition(surface, positionToCheck) then
                    table.add(validPositionsArray, positionToCheck)
                end
            end
        end
    end
    if #validPositionsArray > 0 then
        return validPositionsArray[math.random(#validPositionsArray)]
    else
        return TrainJumper.FindNewPlayerPosition(surface, startingPosition, searchRange * 2, positionsCheckedDict)
    end*/
end

TrainJumper.CheckJumpPosition = function(surface, position)
    if surface.count_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, 0.2)
    } > 0 then
        return false
    else
        return true
    end
end


script.ontick(function() TrainJumper.AllPlayersManager() end) 