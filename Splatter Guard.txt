/c

game.print("Jumps a player on foot off the train track when a moving train gets very close. The player is held still for 1 second after being jumped.")

TrainJumper = {}

TrainJumper.playersJumpedDict = {}
TrainJumper.playerSafeBox = 0.5
TrainJumper.trainSearchSize = 3

TrainJumper.AllPlayersManager = function()
    for i, player in pairs(game.connected_players) do
       TrainJumper.PlayerManager(player)
    end
    TrainJumper.JumpedPlayersManager()
end

TrainJumper.JumpedPlayersManager = function()
    for playerIndex, endTick in pairs(TrainJumper.playersJumpedDict) do
        if endTick >= game.tick then
            if game.players[playerIndex] ~= nil then
                game.players[playerIndex].walking_state = {false}
            else
                table.remove(TrainJumper.playersJumpedDict, playerIndex)
            end
        else
            table.remove(TrainJumper.playersJumpedDict, playerIndex)
        end
    end
end

TrainJumper.PlayerManager = function(player)
	Utility.DebugLogging("PlayerManager", player.name .. " PlayerManager")
    if player.character == nil then
		Utility.DebugLogging("PlayerManager", "no character")
		return
	end
    if player.vehicle ~= nil then
		Utility.DebugLogging("PlayerManager", "in vehicle")
		return
	end
    if not TrainJumper.IsTrackNearPosition(player.surface, player.position, TrainJumper.playerSafeBox) then
		Utility.DebugLogging("PlayerManager", "not near track")
        return
	end
    if not TrainJumper.IsATrainNearPlayer(player) then
		Utility.DebugLogging("PlayerManager", "not near train")
        return
    end
	Utility.DebugLogging("PlayerManager", "going to jump")
    TrainJumper.JumpPlayerToFreeSpot(player)
end

TrainJumper.IsTrackNearPosition = function(surface, position, range)
    if surface.count_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"straight-rail", "curved-rail"},
        limit = 1
    } > 0 then
        return true
    else
        return false
    end
end

TrainJumper.IsATrainNearPlayer = function(player)
	Utility.DebugLogging("IsATrainNearPlayer", player.name .. " IsATrainNearPlayer")
    local trainEntitiesArr = TrainJumper.GetTrainEntitiesNearPositionAsArray(player.surface, player.position, TrainJumper.trainSearchSize)
    if trainEntitiesArr == nil or #trainEntitiesArr == 0 then
		Utility.DebugLogging("IsATrainNearPlayer", "no train entities found near player")
        return false
    end
	Utility.DebugLogging("IsATrainNearPlayer", #trainEntitiesArr .. " train entities found near player")
    local trainsDict = TrainJumper.GetTrainsFromTrainEntitiesAsDictionary(trainEntitiesArr)
	if Utility.debugLogging["IsATrainNearPlayer"] then Utility.DebugLogging("IsATrainNearPlayer", Utility.GetTableLength(trainsDict) .. " trains found for train entities") end
    local playerNearTrackArr = TrainJumper.GetTrackNearPositionAsArray(player.surface, player.position, TrainJumper.playerSafeBox)
	Utility.DebugLogging("IsATrainNearPlayer", #playerNearTrackArr .. " track entities found near player")
	if Utility.debugLogging["IsATrainNearPlayer"] then
		for k, v in pairs(playerNearTrackArr) do
			Utility.DebugLogging("IsATrainNearPlayer", "player near track " .. k .. " position: " .. Utility.PositionToString(v.position))
		end
	end
    for i, train in pairs(trainsDict) do
		Utility.DebugLogging("IsATrainNearPlayer", "reviewing train id " .. i)
        if train.speed ~= 0 then
            local trainsTrackArr = TrainJumper.GetTrackForTrainAsArray(train)
			Utility.DebugLogging("IsATrainNearPlayer", "train " .. i .. " has " .. #trainsTrackArr .. " track pieces")
			if Utility.debugLogging["IsATrainNearPlayer"] then
				for k, v in pairs(trainsTrackArr) do
					Utility.DebugLogging("IsATrainNearPlayer", "train " .. i .. " near track " .. k .. " position: " .. Utility.PositionToString(v.position))
				end
			end
            for j, trainTrack in pairs(trainsTrackArr) do
                for k, nearTrack in pairs(playerNearTrackArr) do
                    if nearTrack.position.x == trainTrack.position.x and nearTrack.position.y == trainTrack.position.y then
						Utility.DebugLogging("IsATrainNearPlayer", "player near track that is near train")
                        return true
                    end
                end
            end
        end
    end
	Utility.DebugLogging("IsATrainNearPlayer", "player not near track that is near train")
    return false
end

TrainJumper.GetTrackForTrainAsArray = function(train)
    local trackArr = {}
    local trackStart = nil
    
	if train.speed > 0 then
		trackStart = train.front_rail
	else
		trackStart = train.back_rail
	end
	
    table.insert(trackArr, trackStart)
    for i, track in pairs(TrainJumper.GetConnectedTrack(trackStart, defines.rail_direction.front)) do
        table.insert(trackArr, track)
    end
    for i, track in pairs(TrainJumper.GetConnectedTrack(trackStart, defines.rail_direction.back)) do
        table.insert(trackArr, track)
    end
	
	return trackArr
end

TrainJumper.GetConnectedTrack = function(track, railDirection)
    local nextRail = nil
    local tracks = {}
    
    nextRail = track.get_connected_rail{rail_direction = railDirection, rail_connection_direction = defines.rail_connection_direction.straight}
    if nextRail ~= nil then
        table.insert(tracks, nextRail)
    end
    nextRail = track.get_connected_rail{rail_direction = railDirection, rail_connection_direction = defines.rail_connection_direction.right}
    if nextRail ~= nil then
        table.insert(tracks, nextRail)
    end
    nextRail = track.get_connected_rail{rail_direction = railDirection, rail_connection_direction = defines.rail_connection_direction.left}
    if nextRail ~= nil then
        table.insert(tracks, nextRail)
    end
    
    return tracks
end

TrainJumper.GetTrackNearPositionAsArray = function(surface, position, range)
    return surface.find_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"straight-rail", "curved-rail"}
    }
end

TrainJumper.GetTrainEntitiesNearPositionAsArray = function(surface, position, range)
    return surface.find_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"locomotive", "cargo-wagon", "fluid-wagon"}
    }
end

TrainJumper.GetTrainsFromTrainEntitiesAsDictionary = function(trainEntitiesArr)
    local trainsDict = {}
    for i, trainEntity in pairs(trainEntitiesArr) do
        local train = trainEntity.train
		if trainsDict[train.id] == nil then
			trainsDict[train.id] = train
		end
	end
    return trainsDict
end

TrainJumper.JumpPlayerToFreeSpot = function(player)
    local newPosition = TrainJumper.FindNewPlayerPosition(player.surface, player.position, 1)
    if not player.teleport(newPosition, player.surface) then
        game.print("ERROR - failed to jump player '" .. player.name .. "' to position(" .. newPosition.x .. ", " .. newPosition.y .. ")")
    end
    TrainJumper.playersJumpedDict[player.index] = game.tick + 60
end

TrainJumper.FindNewPlayerPosition = function(surface, startingPosition, searchRange, positionsCheckedDict)
    if positionsCheckedDict == nil then positionsCheckedDict = {} end
    local validPositionsArr = {}
    for x = startingPosition.x - searchRange, startingPosition.x + searchRange, 0.1 do
        for y = startingPosition.y - searchRange, startingPosition.y + searchRange, 0.1 do
            if positionsCheckedDict[{x,y}] == nil then
                positionsCheckedDict[{x,y}] = "done"
                local positionToCheck = {x = x, y = y}
                if TrainJumper.CheckJumpPosition(surface, positionToCheck) then
                    table.insert(validPositionsArr, positionToCheck)
                end
            end
        end
    end
    if #validPositionsArr > 0 then
        return validPositionsArr[math.random(#validPositionsArr)]
    else
        return TrainJumper.FindNewPlayerPosition(surface, startingPosition, searchRange * 2, positionsCheckedDict)
    end
end

TrainJumper.CheckJumpPosition = function(surface, position)
    if surface.count_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, TrainJumper.playerSafeBox)
    } > 0 then
        return false
    end
    if not surface.can_place_entity{
        name = "player",
        position = position
    } then
        return false
    end
    return true
end




Utility = {}
Utility.debugLogging = {}
Utility.debugLogging["PlayerManager"] = false
Utility.debugLogging["IsATrainNearPlayer"] = false

Utility.DoBoundingBoxesOverlap = function(box1, box2)
    if box1.left_top.x <= box2.right_bottom.x or box1.right_bottom.x >= box1.left_top.x or box1.left_top.y <= box2.right_bottom.y or box1.right_bottom.y >= box1.left_top.y then
        return true
    else
        return false
    end
end

Utility.CalculateBoundingBoxFromPositionAndRange = function(position, range)
    return {
        left_top = {
            x = position.x - range,
            y = position.y - range,
        },
        right_bottom = {
            x = position.x + range,
            y = position.y + range,
        }
    }
end

Utility.DebugLogging = function(option, text)
	if Utility.debugLogging[option] then
		game.write_file("SplatterGuard_logOutput.txt", tostring(text) .. "\r\n", true)
	end
end

Utility.GetTableLength = function(table)
	local count = 0
	for k,v in pairs(table) do
		 count = count + 1
	end
	return count
end

Utility.PositionToString = function(position)
	return "(" .. position.x .. ", " .. position.y ..")"
end





script.on_event(defines.events.on_tick, function() TrainJumper.AllPlayersManager() end)