/c

game.print("Jumps a player on foot off the train track when a moving train gets very close. The player is held still for 1 second after being jumped.")
game.print("corners are very rough and if standing on adjacnt track get triggered incorrectly")

TrainJumper = {}

TrainJumper.playersJumpedDict = {}
TrainJumper.playerSafeBox = 0.5

TrainJumper.AllPlayersManager = function()
    for i, player in pairs(game.connected_players) do
       TrainJumper.PlayerManager(player)
    end
    TrainJumper.JumpedPlayersManager()
end

TrainJumper.JumpedPlayersManager = function()
    for playerIndex, endTick in ipairs(TrainJumper.playersJumpedDict) do
        if endTick >= game.tick then
            if game.players[playerIndex] ~= nil then
                game.players[playerIndex].walking_state = {false}
            else
                table.remove(TrainJumper.playersJumpedDict, playerIndex)
            end
        else
            table.remove(TrainJumper.playersJumpedDict, playerIndex)
        end
    end
end

TrainJumper.PlayerManager = function(player)
    if player.character == nil then return end
    if player.vehicle ~= nil then return end
    if not TrainJumper.IsTrackNearPosition(player.surface, player.position, TrainJumper.playerSafeBox) then return end
    if TrainJumper.IsATrainNearPlayer(player) then
        TrainJumper.JumpPlayerToFreeSpot(player)
    end
end

TrainJumper.IsTrackNearPosition = function(surface, position, range)
    if surface.count_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"straight-rail", "curved-rail"},
        limit = 1
    } > 0 then
        return true
    else
        return false
    end
end

TrainJumper.IsATrainNearPlayer = function(player)
    local trainEntities = TrainJumper.GetNearTrainEntities(player.surface, player.position, 2.5)
    if trainEntities == nil or #trainEntities == 0 then
        return false
    end
    local playersSafeBox = Utility.CalculateBoundingBoxFromPositionAndRange(player.position, TrainJumper.playerSafeBox)
    for i, trainEntity in pairs(trainEntities) do
        if trainEntity.train ~= nil and trainEntity.train.speed ~= 0 then
            if Utility.DoBoundingBoxesOverlap(playersSafeBox, trainEntity.bounding_box) then
                return true
            end
        end
    end
    return false
end

TrainJumper.GetNearTrainEntities = function(surface, position, range)
    return surface.find_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"locomotive", "cargo-wagon", "fluid-wagon"}
    }
end

TrainJumper.JumpPlayerToFreeSpot = function(player)
    local newPosition = TrainJumper.FindNewPlayerPosition(player.surface, player.position, 1)
    player.teleport(newPosition, player.surface)
    TrainJumper.playersJumpedDict[player.index] = game.tick + 60
    game.print("jumped, make shinyness: " .. newPosition.x .. " : " .. newPosition.y)
end

TrainJumper.FindNewPlayerPosition = function(surface, startingPosition, searchRange, positionsCheckedDict)
    if positionsCheckedDict == nil then positionsCheckedDict = {} end
    local validPositionsArray = {}
    for x = startingPosition.x - searchRange, startingPosition.x + searchRange, 0.1 do
        for y = startingPosition.y - searchRange, startingPosition.y + searchRange, 0.1 do
            if positionsCheckedDict[{x,y}] == nil then
                positionsCheckedDict[{x,y}] = "done"
                local positionToCheck = {x = x, y = y}
                if TrainJumper.CheckJumpPosition(surface, positionToCheck) then
                    table.insert(validPositionsArray, positionToCheck)
                end
            end
        end
    end
    if #validPositionsArray > 0 then
        return validPositionsArray[math.random(#validPositionsArray)]
    else
        return TrainJumper.FindNewPlayerPosition(surface, startingPosition, searchRange * 2, positionsCheckedDict)
    end
end

TrainJumper.CheckJumpPosition = function(surface, position)
    if surface.count_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, TrainJumper.playerSafeBox)
    } > 0 then
        return false
    else
        return true
    end
end


Utility = {}

Utility.DoBoundingBoxesOverlap = function(box1, box2)
    if box1.left_top.x <= box2.right_bottom.x or box1.right_bottom.x >= box1.left_top.x or box1.left_top.y <= box2.right_bottom.y or box1.right_bottom.y >= box1.left_top.y then
        return true
    else
        return false
    end
end

Utility.CalculateBoundingBoxFromPositionAndRange = function(position, range)
    return {
        left_top = {
            x = position.x - range,
            y = position.y - range,
        },
        right_bottom = {
            x = position.x + range,
            y = position.y + range,
        }
    }
end




script.on_event(defines.events.on_tick, function() TrainJumper.AllPlayersManager() end) 