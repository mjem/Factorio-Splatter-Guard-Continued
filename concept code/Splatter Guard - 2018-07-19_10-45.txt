/c

game.print("Jumps a player on foot off the train track when a moving train gets very close. The player is held still for 1 second after being jumped.")

Utility = {}

Utility.DoBoundingBoxesOverlap = function(box1, box2)
    if box1.left_top.x <= box2.right_bottom.x or box1.right_bottom.x >= box1.left_top.x or box1.left_top.y <= box2.right_bottom.y or box1.right_bottom.y >= box1.left_top.y then
        return true
    else
        return false
    end
end

Utility.CalculateBoundingBoxFromPositionAndRange = function(position, range)
    return {
        left_top = {
            x = position.x - range,
            y = position.y - range,
        },
        right_bottom = {
            x = position.x + range,
            y = position.y + range,
        }
    }
end




TrainJumper = {}

TrainJumper.playersJumpedDict = {}

TrainJumper.AllPlayersManager = function()
    for i, player in pairs(game.connected_players) do
       TrainJumper.PlayerManager(player)
    end
    TrainJumper.JumpedPlayersManager()
end

TrainJumper.JumpedPlayersManager = function()
    for playerIndex, endTick in ipairs(TrainJumper.playersJumpedDict) do
        if endTick >= game.tick then
            if game.players[playerIndex] ~= nil then
                game.players[playerIndex].walking_state = {false}
            else
                table.remove(TrainJumper.playersJumpedDict, playerIndex)
            end
        else
            table.remove(TrainJumper.playersJumpedDict, playerIndex)
        end
    end
end

TrainJumper.PlayerManager = function(player)
    if player.character == nil then return end
    if player.vehicle ~= nil then return end

    if TrainJumper.IsATrainNearPlayer(player) then
        TrainJumper.JumpPlayerToFreeSpot(player)
    end
end

TrainJumper.IsATrainNearPlayer = function(player)
    local trainEntities = TrainJumper.GetNearTrainEntities(player.surface, player.position, 2.5)
    if trainEntities == nil or #trainEntities == 0 then
        return false
    end
    local playersSafeBox = Utility.CalculateBoundingBoxFromPositionAndRange(player.position, 0.1)
    for i, trainEntity in pairs(trainEntities) do
        if trainEntity.train ~= nil and trainEntity.train.speed ~= 0 then
            if Utility.DoBoundingBoxesOverlap(playersSafeBox, trainEntity.bounding_box) then
                return true
            end
        end
    end
    return false
end

TrainJumper.GetNearTrainEntities = function(surface, position, range)
    return surface.find_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, range),
        type = {"locomotive", "cargo-wagon", "fluid-wagon"}
    }
end

TrainJumper.JumpPlayerToFreeSpot = function(player)
    local newPosition = TrainJumper.FindNewPlayerPosition(player.surface, player.position)
    player.teleport(newPosition, player.surface)
    TrainJumper.playersJumpedDict[player.index] = game.tick + 60
    game.print("jumped, make shinyness: " .. newPosition.x .. " : " .. newPosition.y)
end

TrainJumper.FindNewPlayerPosition = function(surface, startingPosition, searchRange, positionsCheckedDict)
    if searchRange == nil then searchRange = 1 end
    local newPosition = surface.find_non_colliding_position("player", startingPosition, searchRange, 0.1)
    if newPosition ~= nil then
        return newPosition
    else
        return TrainJumper.FindNewPlayerPosition(surface, startingPosition, searchRange * 2)
    end
end

TrainJumper.CheckJumpPosition = function(surface, position)
    if surface.count_entities_filtered{
        area = Utility.CalculateBoundingBoxFromPositionAndRange(position, 0.2)
    } > 0 then
        return false
    else
        return true
    end
end




script.on_event(defines.events.on_tick, function() TrainJumper.AllPlayersManager() end) 